#!/bin/bash

SUBCOMMAND='exec'

POSITIONAL_ARGS=()

while [[ $# -gt 0 ]]; do
  case $1 in
    -x|--exec)
      CMD_EXECUTE="$2"
      shift # past argument
      shift # past value
      ;;
    -l|--log-file)
      CMD_LOG_FILE="$2"
      shift # past argument
      shift # past value
      ;;
    -b|--branch)
      GH_BRANCH_NAME="$2"
      shift # past argument
      shift # past value
      ;;
    -C|--no-clean)
      NO_CLEAN=1
      shift # past argument
      ;;
    --debug)
      DEBUG=1
      shift # past argument
      ;;
    -h|--help)
      HELP=1
      shift # past argument
      ;;
    -*|--*)
      echo "Unknown option $1."
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
  esac
done

set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

if [[ -n "$HELP" ]]; then
  echo ""
  echo "Usage: ghelper exec [options] <list of git repositories>"
  echo ""
  echo "Options:"
  echo ""
  echo "  -x, --exec <command>        Command to execute."
  echo "  -l, --log-file <file>       Log file to write output to."
  echo "  -b, --branch <name>         Name of the branch to checkout."
  echo "  -C, --no-clean              Do not clean up working directory."
  echo "  -h, --help                  Show this help message."
  echo "  --debug                     Enable debug mode."
  echo ""
  echo "Examples:"
  echo ""
  echo "1. Check if the file 'README.md' exists in the main branch of the repository '3lvia/ghelper':"
  echo "   ghelper exec -x 'ls README.md' 3lvia/ghelper"
  echo ""
  echo "2. Run a Trivy scan on the repositories '3lvia/core-terraform' and '3lvia/runtimeservice-terraform':"
  echo "   ghelper exec -x 'trivy --severity HIGH .' 3lvia/core-terraform,3lvia/runtimeservice-terraform"
  echo ""

  exit 0
fi


# Required arguments

if [[ -n $1 ]]; then
  GIT_REPOS="$1"
else
  echo "exec: No list of git repositories provided, got: $1"
  exit 1
fi


# Debug mode

if [[ -n $DEBUG ]]; then
  printf "\n\n"
  printf "%sDebug mode enabled:%s\n" "$BLUE" "$NORMAL"
  printf "SUBCOMMAND: %s\n" "$SUBCOMMAND"
  printf "%sCMD_EXECUTE%s: %s\n" "$UNDERLINE" "$NORMAL" "$CMD_EXECUTE"
  printf "%sCMD_LOG_FILE%s: %s\n" "$UNDERLINE" "$NORMAL" "$CMD_LOG_FILE"
  printf "%sGH_BRANCH_NAME%s: %s\n" "$UNDERLINE" "$NORMAL" "$GH_BRANCH_NAME"
  printf "%sNO_CLEAN%s: %s\n" "$UNDERLINE" "$NORMAL" "$NO_CLEAN"
  printf "%sGIT_REPOS%s: %s\n" "$UNDERLINE" "$NORMAL" "$GIT_REPOS"
  printf "%sgit version%s: $(git --version)\n" "$UNDERLINE" "$NORMAL"
  printf "%sGitHub CLI version%s: " "$UNDERLINE" "$NORMAL" && echo $(gh --version)
  printf "\n\n"
fi


# Determine list of git repositories

if [ -f "$GIT_REPOS" ]; then
  printf "> Reading list of git repositories from file %s%s%s.\n" "$BLUE" "$GIT_REPOS" "$NORMAL"
  GIT_REPOS="$(cat "$GIT_REPOS")"
else
  printf "> Reading list of git repositories from argument as comma separated list.\n"
  GIT_REPOS=$(echo "$GIT_REPOS" | tr "," "\n")
fi

if [[ -z "$GIT_REPOS" ]]; then
  echo "> %sNo git repositories found.%s"
  exit 1
fi

# Create working directory

WORKING_DIR=$(mktemp -d)
printf "> Creating working-directory in %s%s%s.\n" "$BLUE" "$WORKING_DIR" "$NORMAL"
cd "$WORKING_DIR"


# Process each repository in list

printf "\n"
for GIT_REPO in $GIT_REPOS; do
  printf "> Processing repository %s%s%s:\n" "$BLUE" "$GIT_REPO" "$NORMAL"


  # Clone repository and setup directory

  printf "   > Cloning repository.\n"
  GIT_REPO_DIR=$WORKING_DIR/"$(basename "$GIT_REPO")"
  git clone git@github.com:"$GIT_REPO" "$GIT_REPO_DIR" -q

  printf "   > Switching directory to %s%s%s.\n" "$BLUE" "$GIT_REPO_DIR" "$NORMAL"
  cd "$GIT_REPO_DIR"


  # Determine main branch

  printf "   > Determining main branch:\n"
  if [[ -n "$GH_BRANCH_NAME" ]]; then
    printf "      > Using main branch %s%s%s, set by user.\n" "$BLUE" "$GH_BRANCH_NAME" "$NORMAL"
    MAIN_BRANCH_FOR_REPO="$GH_BRANCH_NAME"
  else
    for MAIN_BRANCH in main master trunk develop; do
      printf "      > Checking if %s%s%s exists in remote.\n" "$BLUE" "$MAIN_BRANCH" "$NORMAL"
      MAIN_BRANCH_GREP_MATCH=$(git branch -r | { grep "origin/$MAIN_BRANCH" || true; })
      if [[ -n "$MAIN_BRANCH_GREP_MATCH" ]]; then
          printf "      > Found branch %s%s%s.\n" "$BLUE" "$MAIN_BRANCH" "$NORMAL"
          MAIN_BRANCH_FOR_REPO="$MAIN_BRANCH"
      else
        printf "      > Branch %s%s%s not found in remote, continuing.\n" "$BLUE" "$MAIN_BRANCH" "$NORMAL"
      fi
    done

    if [[ -z "$MAIN_BRANCH_FOR_REPO" ]]; then
      printf "   > %sNo main branch found, exiting.%s" "$RED" "$NORMAL"
      exit 1
    fi
  fi

  printf "   > Going with branch %s%s%s.\n" "$BLUE" "$MAIN_BRANCH_FOR_REPO" "$NORMAL"
  git checkout "$MAIN_BRANCH_FOR_REPO" -q


  # Execute command

  set +e # Disable exit on error
  printf "   > Executing command %s'%s'%s.\n" "$BLUE" "$CMD_EXECUTE" "$NORMAL"
  if [[ -n "$CMD_LOG_FILE" ]]; then
    printf "   > Appending output to %s%s%s.\n" "$BLUE" "$CMD_LOG_FILE" "$NORMAL"
    echo "Repository: $GIT_REPO" >> "$CMD_LOG_FILE"
    $CMD_EXECUTE >> "$CMD_LOG_FILE" 2>&1
  else
    $CMD_EXECUTE
  fi
  set -e # Enable exit on error

  printf "\n"
done


# Clean up (or not)

if [[ -n "$NO_CLEAN" ]]; then
  echo "> Done, not cleaning up."
else
  echo "> Done, cleaning up."
  rm -rf "$WORKING_DIR"
fi
